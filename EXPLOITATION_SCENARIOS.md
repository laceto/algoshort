# Exploitation Scenarios for stop_loss.py
## Demonstrating Real-World Failure Modes

---

## Scenario 1: The Zero Price Disaster

**Situation:** Data feed has a glitch and sends zero prices for a few ticks

```python
# Real data suddenly gets zeros
df = pd.DataFrame({
    'open': [100, 0, 0, 102],      # Glitch!
    'high': [105, 5, 5, 107],
    'low': [95, -5, -5, 97],
    'close': [100, 0, 0, 102],
    'signal': [1, 1, 1, 1]  # Still holding long
})

calc = StopLossCalculator(df)
result = calc.fixed_percentage_stop_loss('signal', percentage=0.05)
```

**Result:**
```
Row 0: stop_loss = 95.0     ✓ Normal
Row 1: stop_loss = 0.0      ✗ DISASTER!
Row 2: stop_loss = 0.0      ✗ DISASTER!
Row 3: stop_loss = 96.9     ✓ Recovered
```

**What Happens in Production:**
1. Trading system sees stop_loss = 0.0
2. Tries to place stop order at $0
3. Broker rejects order (invalid price)
4. **Position has NO STOP LOSS**
5. Market crashes, you lose everything

**How to Exploit:** Feed garbage data to the system

**Impact:** Unlimited loss potential

---

## Scenario 2: The Negative Multiplier Attack

**Situation:** Someone misconfigures the ATR multiplier (typo: -2 instead of 2)

```python
df = pd.DataFrame({
    'open': [100, 101, 102],
    'high': [105, 106, 107],
    'low': [95, 96, 97],
    'close': [100, 101, 102],
    'signal': [1, 1, 1]  # Long position
})

calc = StopLossCalculator(df)
result = calc.atr_stop_loss('signal', window=2, multiplier=-2)
```

**Result:**
```
ATR = 10
Long stop should be: 100 - (10 * 2) = 80
Actual stop calculated: 100 - (10 * -2) = 120
```

**What Happens in Production:**
1. You enter long at 100
2. Stop is placed at 120 (ABOVE entry!)
3. Price immediately triggers stop (current price < 120)
4. **Immediate stop-out on entry**
5. You pay spread both ways, instant loss

**How to Exploit:**
- Configuration error
- Malicious parameter injection
- Copy-paste error in config file

**Impact:** Guaranteed loss on every trade

---

## Scenario 3: The Division by Zero Trap

**Situation:** Using classified_pivot_stop_loss with zero close prices

```python
df = pd.DataFrame({
    'open': [1, 0, 1],
    'high': [2, 1, 2],
    'low': [-1, -1, -1],
    'close': [0, 0, 0],  # Zero closes
    'signal': [1, 1, 1]
})

calc = StopLossCalculator(df)
result = calc.classified_pivot_stop_loss('signal', distance_threshold=0.01)
```

**Result:**
```python
# Line 250:
is_long_too_close = is_long & (np.abs(close - stop) / close < distance_threshold)
#                                                       ^^^^^ DIVISION BY ZERO!

# Result:
signal_stop_loss = [nan, nan, nan]
```

**What Happens in Production:**
1. Trading system receives NaN stop losses
2. Depending on implementation:
   - A) Crashes with ValueError
   - B) Ignores stop (no protection)
   - C) Treats NaN as 0 (disaster)
3. **Silent failure** - no error raised by stop_loss.py

**Impact:** Positions without protection

---

## Scenario 4: The Extreme Percentage Explosion

**Situation:** User thinks percentage is in basis points, enters 500 (meaning 5%)

```python
df = pd.DataFrame({
    'open': [100, 101, 102],
    'high': [105, 106, 107],
    'low': [95, 96, 97],
    'close': [100, 101, 102],
    'signal': [1, -1, 1]
})

calc = StopLossCalculator(df)
# User meant 5% but entered 5.0 (500%)
result = calc.fixed_percentage_stop_loss('signal', percentage=5.0)
```

**Result:**
```
Row 0 (long):  stop = 100 * (1 - 5.0) = -400.0
Row 1 (short): stop = 101 * (1 + 5.0) = 606.0
Row 2 (long):  stop = 102 * (1 - 5.0) = -408.0
```

**What Happens in Production:**
1. Broker receives order: "Set stop at -$400"
2. Order rejected (negative price)
3. Alternative: Some systems clip to 0
4. **Position has no stop or wrong stop**

**How to Exploit:** Configuration file accepts any float

**Impact:** Loss of risk management

---

## Scenario 5: The High-Low Inversion

**Situation:** Data feed has corrupted OHLC data (high < low)

```python
df = pd.DataFrame({
    'open': [100, 101, 102],
    'high': [95, 96, 97],      # HIGH < LOW!
    'low': [105, 106, 107],
    'close': [100, 101, 102],
    'signal': [1, 1, 1]
})

calc = StopLossCalculator(df)
result = calc.atr_stop_loss('signal', window=2, multiplier=2.0)
```

**Result:**
```
True Range = high - low = 95 - 105 = -10
ATR = -10
Stop distance = -10 * 2.0 = -20
Long stop = 100 - (-20) = 120  (WRONG DIRECTION!)
```

**What Happens in Production:**
1. Stop placed at 120 (above entry of 100)
2. Immediate trigger
3. Or: Stop never triggers, position unprotected

**How to Exploit:** Feed corrupted OHLC data

**Impact:** Wrong directional stops

---

## Scenario 6: The NaN Signal Leak

**Situation:** Signal calculation produces NaN for some rows

```python
df = pd.DataFrame({
    'open': [100, 101, 102, 103, 104],
    'high': [105, 106, 107, 108, 109],
    'low': [95, 96, 97, 98, 99],
    'close': [100, 101, 102, 103, 104],
    'signal': [1, 1, np.nan, np.nan, -1]  # NaN due to calculation error
})

calc = StopLossCalculator(df)
result = calc.atr_stop_loss('signal')
```

**Result:**
```
Row 0: signal=1,   stop=80.0
Row 1: signal=1,   stop=81.0
Row 2: signal=nan, stop=81.0  <- ffilled from previous!
Row 3: signal=nan, stop=81.0  <- ffilled from previous!
Row 4: signal=-1,  stop=124.0
```

**What Happens in Production:**
1. Rows 2-3 have NaN signals (no position)
2. But stops are ffilled from long position
3. If you check "is stop hit" when NaN:
   - You might exit when you're not even in position
   - Or keep old stop when switching positions

**How to Exploit:** Inject NaN in signal column

**Impact:** False exits, confused state management

---

## Scenario 7: The Infinity Cascade

**Situation:** Extreme price movement or calculation overflow produces inf

```python
df = pd.DataFrame({
    'open': [100, np.inf, 102],
    'high': [105, np.inf, 107],
    'low': [95, 96, 97],
    'close': [100, np.inf, 102],
    'signal': [1, 1, 1]
})

calc = StopLossCalculator(df)
result = calc.atr_stop_loss('signal')
```

**Result:**
```
Row 0: stop = 80.0
Row 1: stop = inf
Row 2: stop = 82.0  (recovered)
```

**What Happens in Production:**
1. Trading system receives stop_loss = inf
2. Depending on downstream system:
   - A) Crashes with "invalid order price"
   - B) Treats as "no stop"
   - C) Clips to max float (nonsense value)
3. **Data corruption propagates**

**How to Exploit:** Feed extreme prices or overflow calculations

**Impact:** System instability

---

## Scenario 8: The ffill Time Bomb

**Situation:** Position changes from long → flat → short

```python
df = pd.DataFrame({
    'open': [100, 101, 102, 103, 104, 105, 106],
    'high': [105, 106, 107, 108, 109, 110, 111],
    'low': [95, 96, 97, 98, 99, 100, 101],
    'close': [100, 101, 102, 103, 104, 105, 106],
    'signal': [1, 1, 0, 0, -1, -1, -1]  # Long → Flat → Short
})

calc = StopLossCalculator(df)
result = calc.atr_stop_loss('signal', window=3, multiplier=2.0)
```

**Result:**
```
Row 0: signal=1,  stop=80.0   (long stop)
Row 1: signal=1,  stop=81.0   (long stop)
Row 2: signal=0,  stop=81.0   (FFILLED FROM LONG!)
Row 3: signal=0,  stop=81.0   (FFILLED FROM LONG!)
Row 4: signal=-1, stop=124.0  (short stop)
```

**What Happens in Production:**

**Bad Implementation:**
```python
for i in range(len(df)):
    if price[i] < stop_loss[i]:
        exit_position()  # BUG: Exits when signal=0!
```

**Correct Implementation:**
```python
for i in range(len(df)):
    if signal[i] != 0 and price[i] < stop_loss[i]:
        exit_position()  # Only check when in position
```

**How to Exploit:** Rely on stop_loss column without checking signal

**Impact:** False exits when flat

---

## Scenario 9: The Zero Window Collapse

**Situation:** Configuration error sets window=0

```python
df = pd.DataFrame({
    'open': [100, 101, 102],
    'high': [105, 106, 107],
    'low': [95, 96, 97],
    'close': [100, 101, 102],
    'signal': [1, 1, 1]
})

calc = StopLossCalculator(df)
result = calc.moving_average_stop_loss('signal', window=0)
```

**Result:**
```
pandas rolling(window=0) produces:
signal_stop_loss = [nan, nan, nan]
```

**What Happens in Production:**
1. All stops are NaN
2. Trading system has no valid stops
3. **Silent failure** - no exception raised
4. Positions unprotected

**Why It Happens:**
- `breakout_channel_stop_loss` validates window
- `moving_average_stop_loss` does NOT validate
- **Inconsistent implementation**

**Impact:** No stops on positions

---

## Scenario 10: The Single Row Deception

**Situation:** Backtesting on small dataset or edge case with 1 row

```python
df = pd.DataFrame({
    'open': [100],
    'high': [105],
    'low': [95],
    'close': [100],
    'signal': [1]
})

calc = StopLossCalculator(df)
result = calc.atr_stop_loss('signal', window=14)  # Want 14-period ATR
```

**Result:**
```
ATR calculated with min_periods=1:
ATR = [10.0]  (based on 1 sample, not 14!)
Stop loss = 80.0
```

**What Happens in Production:**
1. User expects 14-period ATR for reliability
2. Gets 1-period ATR (just current true range)
3. **Stop is based on single bar** - highly unreliable
4. No warning issued
5. Backtest looks fine with lucky data
6. **Production fails** with normal volatility

**How to Exploit:** Test on small datasets, looks good, fails in production

**Impact:** Unreliable stops, poor risk management

---

## Scenario 11: The String Injection

**Situation:** DataFrame columns contain mixed types

```python
df = pd.DataFrame({
    'open': [100, 'broken', 102],
    'high': [105, 106, 107],
    'low': [95, 96, 97],
    'close': [100, 101, 102],
    'signal': [1, 1, 1]
})

calc = StopLossCalculator(df)
result = calc.fixed_percentage_stop_loss('signal')
```

**Result:**
```
Row 0: stop = 95.0
Row 1: stop = nan  (100 * 0.95 with string fails)
Row 2: stop = 96.9
```

**What Happens in Production:**
1. No type validation on initialization
2. Calculations proceed with mixed types
3. NaN propagates through
4. **Silent failure** until orders are placed

**How to Exploit:** Feed CSV data without type conversion

**Impact:** Partial loss of stops

---

## Scenario 12: The Config File Bomb

**Situation:** User config file has typo

```yaml
# config.yaml
stop_loss:
  method: atr
  window: 14
  multiplier: -2.5  # TYPO! Should be 2.5
```

```python
config = yaml.load('config.yaml')
calc = StopLossCalculator(df)
result = calc.get_stop_loss(
    'signal',
    config['stop_loss']['method'],
    **config['stop_loss']
)
```

**Result:**
```
Stops in WRONG direction
Every position immediately stopped out
No error raised - "valid" configuration
```

**What Happens in Production:**
1. Deploy to production
2. All positions exit immediately
3. **Massive losses from spreads**
4. Takes hours to discover config error
5. Meanwhile, hundreds of failed trades

**How to Exploit:** Typo in config file

**Impact:** Complete system failure

---

## Real-World Impact Summary

| Scenario | Severity | Silent? | Impact |
|----------|----------|---------|--------|
| Zero prices | CRITICAL | ✓ | No protection |
| Negative multiplier | CRITICAL | ✓ | Wrong direction |
| Division by zero | CRITICAL | ✓ | NaN stops |
| Extreme percentage | CRITICAL | ✓ | Negative prices |
| High-low inversion | HIGH | ✓ | Negative ATR |
| NaN signal leak | HIGH | ✓ | NaN stops |
| Infinity cascade | HIGH | ✓ | Data corruption |
| ffill time bomb | MEDIUM | ✓ | False exits |
| Zero window | MEDIUM | ✓ | No stops |
| Single row | MEDIUM | ✓ | Unreliable stops |
| String injection | MEDIUM | ✓ | Partial stops |
| Config file bomb | CRITICAL | ✓ | System failure |

**All 12 scenarios fail SILENTLY**

---

## Defense Recommendations

### 1. Input Validation Layer

```python
def _validate_data(self):
    """Comprehensive data validation"""
    # Type checking
    for col in self.price_cols.values():
        if not pd.api.types.is_numeric_dtype(self._data[col]):
            raise ValueError(f"{col} must be numeric")

    # Range checking
    price_cols = list(self.price_cols.values())
    if (self._data[price_cols] <= 0).any().any():
        raise ValueError("Prices must be positive")

    # Sanity checking
    high = self._data[self.price_cols['high']]
    low = self._data[self.price_cols['low']]
    if (high < low).any():
        raise ValueError("High must be >= low")

    # NaN/inf checking
    if self._data[price_cols].isna().any().any():
        raise ValueError("Data contains NaN values")
    if self._data[price_cols].isin([np.inf, -np.inf]).any().any():
        raise ValueError("Data contains infinite values")
```

### 2. Parameter Validation

```python
def atr_stop_loss(self, signal, price_col=None, window=14, multiplier=2.0):
    # Validate multiplier
    if multiplier <= 0:
        raise ValueError(f"multiplier must be positive, got {multiplier}")
    if multiplier > 100:
        raise ValueError(f"multiplier={multiplier} is unreasonably large")

    # Validate window
    if window < 1:
        raise ValueError(f"window must be >= 1, got {window}")
    if window > len(self.data):
        warnings.warn(f"window={window} exceeds data length={len(self.data)}")

    # ... rest of implementation
```

### 3. Output Validation

```python
def _validate_stops(self, stops, price, signal):
    """Ensure stops are logical"""
    long_mask = signal > 0
    short_mask = signal < 0

    # Long stops must be below price
    if (stops[long_mask] >= price[long_mask]).any():
        raise ValueError("Long stops must be below entry price")

    # Short stops must be above price
    if (stops[short_mask] <= price[short_mask]).any():
        raise ValueError("Short stops must be above entry price")

    # No negative prices
    if (stops < 0).any():
        raise ValueError("Stop losses cannot be negative")

    # No NaN in active signals
    active = signal != 0
    if stops[active].isna().any():
        raise ValueError("Stop loss cannot be NaN for active signals")
```

### 4. Comprehensive Testing

```python
def test_extreme_parameters():
    """Test edge cases"""
    test_cases = [
        {'multiplier': -1, 'should_fail': True},
        {'multiplier': 0, 'should_fail': True},
        {'multiplier': 1000, 'should_fail': True},
        {'percentage': -0.1, 'should_fail': True},
        {'percentage': 2.0, 'should_fail': True},
        {'window': 0, 'should_fail': True},
        {'window': -5, 'should_fail': True},
    ]

    for case in test_cases:
        # Assert that invalid params raise ValueError
        ...
```

---

## Conclusion

These 12 exploitation scenarios demonstrate that **stop_loss.py has significant production risks**. The combination of:

1. **No input validation** (data or parameters)
2. **Silent failures** (wrong output, no errors)
3. **Mathematical edge cases** (division by zero, negative values)
4. **Inconsistent validation** (some methods check, others don't)

...creates a **dangerous system** for live trading where incorrect stop losses can lead to catastrophic losses.

**The code assumes perfect input and well-behaved users.**

**Reality: Data is messy, users make typos, systems glitch.**

**Recommendation:** Implement all defensive checks before production deployment.
